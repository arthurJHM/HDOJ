
#include<stdio.h>
int main()
{
	double s[25],a[25];
	int n,m,i;
	a[1]=1;
	for(i=2;i<=24;i++)
	a[i]=a[i-1]*i;
	s[1]=0;
	s[2]=1;
	s[3]=2;
	for(i=4;i<=24;i++)
	s[i]=(i-1)*(s[i-1]+s[i-2]);
	scanf("%d",&n);
	while(n--){
		scanf("%d",&m);
		printf("%.2lf%%\n",s[m]*100/a[m]);
	}
	return 0;
}


//关于百分号怎么打



http://baike.baidu.com/view/1926671.htm
递推公式

瑞士数学家欧拉按一般情况给出了一个递推公式：
用A、B、C……表示写着n位友人名字的信封，a、b、c……表示n份相应的写好的信纸。把错装的总数为记作f(n)。假设把a错装进B里了，包含着这个错误的一切错装法分两类：
（1）b装入A里，这时每种错装的其余部分都与A、B、a、b无关，应有f(n-2)种错装法。
（2）b装入A、B之外的一个信封，这时的装信工作实际是把（除a之外的）(n-1 )份信纸b、c……装入（除B以外的）n－1个信封A、C……，显然这时装错的方法有f(n-1)种。
总之在a装入B的错误之下，共有错装法f(n-2)+f(n-1)种。a装入C，装入D……的n－2种错误之下，同样都有f(n-2)+f(n-1)种错装法，因此:
f(n)=(n-1) {f(n-1)+f(n-2)}
公式可重新写成 f(n)-nf(n-1)=-[f(n-1)-(n-1)f(n-2)] (n>2)
于是可以得到
f(n)-nf(n-1)=-[f(n-1)-(n-1)f(n-2)]
=((-1)^2)[f(n-2)-(n-2)f(n-3)]
=((-1)^3)[f(n-3)-(n-3)f(n-4)]
=……
=[(-1)^(n-2)][f(2)-2f(1)]
最终得到一个更简单的递推式 f(n)=nf(n-1)+(-1)^(n-2)
或者等价式 f(n)=nf(n-1)+(-1)^(n) n=2,3,4……




#include<stdio.h>
main()
{
    long long a[60],n,i,he;
    a[1]=3;
    a[2]=a[3]=6;
    while (scanf("%lld",&n)!=EOF){
        for (i=4;i<=n;i++)
        a[i]=a[i-1]+a[i-2]*2;
     printf ("%lld\n",a[n]);
    }
    return 0;
}
//有排成一行的ｎ个方格，用红(Red)、粉(Pink)、绿(Green)三色涂每个格子，每格涂一色，要求任何相邻的方格不能同色，且首尾两格也不同色．求全部的满足要求的涂法.
以上就是著名的RPG难题.

解题思路１是递推嘛，f(1)=3,f(2)=6,f(3)=6

　　　　２如果有n个方格，当对第n个方格填色时，有两种情况：

　　　　　１）应该已经对前面n-1个方格填好了色，有f(n-1)种情况，此时第n-1个跟第一个颜色一定不一样，所以第n个只有一种选择。
　　　　　２）对前面n-2个方格填好色，有f(n-2)种情况，第n-1个空格颜色跟第一个颜色一样（否则就成了上面那种情况了），只有一种可能，最后第n个方格可以填两种颜色（因为n-１和１是第同种颜色），所以是　２*f(n-2);

                   可以推出f(n)=f(n-1)+2(n-2),n>=4;



//第二遍做这题时 网上看到的思路

递推：f(n)=f(n-1)+2*f(n-2)
证明：考虑长为n的串。若前n-1位组成的串合法，则由于首尾不同，再添加一位时，只有1种颜色可选；若前n-1位组成的串不合法（首尾相同），那么前n-2位组成的串必须合法（因为最终要组成的n位是合法的）。此时第n位有2种颜色可选。故f(n)=f(n-1)+2*f(n-2)。

边界条件：f(1)=3，f(2)=f(3)=6。

PS：可用特征方程得出n>3时f(n)的封闭形式f(n)=2^n+2*(-1)^n。